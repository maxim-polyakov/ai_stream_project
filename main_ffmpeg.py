#!/usr/bin/env python3
"""
ü§ñ AI Stream —Å FFmpeg —Å—Ç—Ä–∏–º–∏–Ω–≥–æ–º –Ω–∞ YouTube
–í–µ—Ä—Å–∏—è —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π YouTube API
"""

import os
import sys
import json
import random
import asyncio
import threading
import logging
import time
import wave
import subprocess
import hashlib
from datetime import datetime
from typing import List, Dict, Any, Optional
from flask import Flask, render_template, request, jsonify
from flask_socketio import SocketIO, emit
import signal
import shutil

# –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–º–ø–æ—Ä—Ç—ã
try:
    import openai
    import edge_tts
    import pygame

    # –ü–æ–ø—Ä–æ–±—É–µ–º –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å pyaudio
    try:
        import pyaudio

        PYTHON_AUDIO_AVAILABLE = True
    except ImportError:
        PYTHON_AUDIO_AVAILABLE = False
        print("‚ö†Ô∏è PyAudio –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∏—Ö–∏–π –∑–≤—É–∫.")

    from config import Config

    print("‚úÖ –í—Å–µ –æ—Å–Ω–æ–≤–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã")
except ImportError as e:
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞: {e}")
    print("\nüì¶ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:")
    print("pip install flask==2.3.0 flask-socketio==5.3.0 eventlet==0.33.0 openai>=1.3.0")
    print("pip install edge-tts>=6.1.9 pygame>=2.5.0 python-dotenv>=1.0.0")
    sys.exit(1)

# –ü–æ–ø—Ä–æ–±—É–µ–º –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å YouTube API
YOUTUBE_API_AVAILABLE = False
youtube_api_manager = None

try:
    from youtube_direct_api import YouTubeDirectStream

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ñ–∞–π–ª–∞ client_secrets.json
    if os.path.exists('client_secrets.json'):
        try:
            youtube_api_manager = YouTubeDirectStream()
            YOUTUBE_API_AVAILABLE = True
            print("‚úÖ YouTube API –¥–æ—Å—Ç—É–ø–µ–Ω (client_secrets.json –Ω–∞–π–¥–µ–Ω)")
        except Exception as e:
            print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ YouTube API: {e}")
            print("–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä—É—á–Ω–æ–π –≤–≤–æ–¥ Stream Key")
    else:
        print("‚ö†Ô∏è –§–∞–π–ª client_secrets.json –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        print("–î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–π —á–µ—Ä–µ–∑ YouTube API:")
        print("1. –°–æ–∑–¥–∞–π—Ç–µ –ø—Ä–æ–µ–∫—Ç –≤ Google Cloud Console")
        print("2. –í–∫–ª—é—á–∏—Ç–µ YouTube Data API v3")
        print("3. –°–æ–∑–¥–∞–π—Ç–µ OAuth 2.0 Client ID")
        print("4. –°–æ—Ö—Ä–∞–Ω–∏—Ç–µ –∫–∞–∫ client_secrets.json –≤ –∫–æ—Ä–Ω–µ –ø—Ä–æ–µ–∫—Ç–∞")

except ImportError:
    print("‚ö†Ô∏è YouTube API –º–æ–¥—É–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω.")
    print("–î–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–π —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ:")
    print("pip install google-api-python-client google-auth-oauthlib google-auth-httplib2")
except Exception as e:
    print(f"‚ö†Ô∏è –ù–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ YouTube API: {e}")

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('stream.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Flask –∏ SocketIO
app = Flask(__name__, static_folder='stream_ui', template_folder='stream_ui')
app.config['SECRET_KEY'] = 'ai_stream_secret_key_2024'
socketio = SocketIO(app,
                    cors_allowed_origins="*",
                    async_mode='threading',
                    logger=True,
                    engineio_logger=False,
                    ping_timeout=300,
                    ping_interval=60,
                    max_http_buffer_size=1e8)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è OpenAI
if Config.OPENAI_API_KEY:
    from openai import OpenAI

    openai_client = OpenAI(api_key=Config.OPENAI_API_KEY)
else:
    logger.warning("‚ö†Ô∏è OpenAI API –∫–ª—é—á –Ω–µ –Ω–∞–π–¥–µ–Ω. –ë—É–¥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–µ–º–æ-—Å–æ–æ–±—â–µ–Ω–∏—è.")
    openai_client = None

# ========== FFMPEG STREAM MANAGER ==========

class FFmpegStreamManager:
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ FFmpeg —Å—Ç—Ä–∏–º–æ–º –Ω–∞ YouTube"""

    def __init__(self):
        self.stream_process = None
        self.is_streaming = False
        self.stream_key = None
        self.rtmp_url = None
        self.ffmpeg_pid = None
        self.video_source = "black"
        self.ffmpeg_stdin = None
        self.start_time = None
        self.audio_queue = []
        self.is_playing_audio = False
        self.audio_sample_rate = 44100
        self.audio_channels = 2
        self.use_pyaudio = PYTHON_AUDIO_AVAILABLE

    def set_stream_key(self, stream_key: str):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∫–ª—é—á–∞ —Å—Ç—Ä–∏–º–∞"""
        self.stream_key = stream_key
        self.rtmp_url = f"rtmp://a.rtmp.youtube.com/live2/{stream_key}"
        logger.info(f"üîë Stream Key —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {stream_key[:10]}...")
        return True

    def set_video_source(self, source_type: str, source_param: str = None):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞ –≤–∏–¥–µ–æ"""
        self.video_source = source_type
        self.video_param = source_param
        logger.info(f"üìπ –ò—Å—Ç–æ—á–Ω–∏–∫ –≤–∏–¥–µ–æ: {source_type}")

    def start_stream(self, use_audio: bool = True):
        """–ó–∞–ø—É—Å–∫ FFmpeg —Å—Ç—Ä–∏–º–∞ —Å –ø–µ—Ä–µ–¥–∞—á–µ–π –∞—É–¥–∏–æ"""
        if not self.stream_key:
            logger.error("‚ùå Stream Key –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
            return False

        try:
            self.start_time = time.time()

            # –í–∏–¥–µ–æ –∏—Å—Ç–æ—á–Ω–∏–∫
            if self.video_source == "http":
                video_input = [
                    '-f', 'image2pipe',
                    '-i', 'http://localhost:5000/video_feed',
                    '-framerate', '30'
                ]
            elif self.video_source == "x11grab":
                video_input = [
                    '-f', 'x11grab',
                    '-i', ':99',
                    '-video_size', '1920x1080',
                    '-framerate', '30'
                ]
            else:
                video_input = [
                    '-f', 'lavfi',
                    '-i',
                    f'color=c=black:s=1920x1080:r=30:drawtext=text="AI\\\\ Stream\\\\ {datetime.now().strftime("%H:%M")}":fontcolor=white:fontsize=48:x=(w-text_w)/2:y=(h-text_h)/2'
                ]

            # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∞—É–¥–∏–æ
            if use_audio and self.use_pyaudio:
                # –ê—É–¥–∏–æ –≤—Ö–æ–¥ –∏–∑ stdin (—Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ)
                audio_input = [
                    '-f', 's16le',  # 16-bit little-endian PCM
                    '-ar', str(self.audio_sample_rate),
                    '-ac', str(self.audio_channels),
                    '-i', 'pipe:0',  # –ß–∏—Ç–∞—Ç—å –∏–∑ stdin
                ]
            else:
                # –¢–∏—Ö–∏–π –∞—É–¥–∏–æ
                audio_input = [
                    '-f', 'lavfi',
                    '-i', 'anullsrc=channel_layout=stereo:sample_rate=44100'
                ]

            # –ö–æ–º–∞–Ω–¥–∞ FFmpeg
            ffmpeg_cmd = [
                'ffmpeg',

                # –í–∏–¥–µ–æ –∏—Å—Ç–æ—á–Ω–∏–∫ (—Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è)
                '-re',
                '-f', 'lavfi',
                '-i', f'color=...:r=30',

                # –ê—É–¥–∏–æ –∏—Å—Ç–æ—á–Ω–∏–∫ (—Ä–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è + —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è)
                '-re',
                '-f', 's16le',
                '-ar', '44100',
                '-ac', '2',
                '-i', 'pipe:0',

                # –ö–æ–¥–µ–∫–∏
                '-c:v', 'libx264',
                '-preset', 'veryfast',
                '-tune', 'zerolatency',
                '-pix_fmt', 'yuv420p',
                '-g', '60',
                '-b:v', '4500k',

                '-c:a', 'aac',
                '-b:a', '128k',
                '-ar', '44100',
                '-ac', '2',

                # –í–∞–∂–Ω–æ: —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ –∫–∞–∫ –≥–ª–∞–≤–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
                '-async', '1',
                '-vsync', '1',
                '-flush_packets', '1',

                '-f', 'flv',
                self.rtmp_url
            ]

            logger.info(f"üöÄ –ó–∞–ø—É—Å–∫ FFmpeg: {' '.join(ffmpeg_cmd[:10])}...")

            # –ó–∞–ø—É—Å–∫–∞–µ–º FFmpeg
            self.stream_process = subprocess.Popen(
                ffmpeg_cmd,
                stdin=subprocess.PIPE if (use_audio and self.use_pyaudio) else None,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE,
                text=False,
                bufsize=0
            )

            self.is_streaming = True
            self.ffmpeg_pid = self.stream_process.pid
            self.ffmpeg_stdin = self.stream_process.stdin

            # –ó–∞–ø—É—Å–∫ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
            threading.Thread(target=self._monitor_ffmpeg, daemon=True).start()

            # –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∞—É–¥–∏–æ
            if use_audio and self.use_pyaudio:
                threading.Thread(target=self._audio_processor, daemon=True).start()

            logger.info(f"üé¨ FFmpeg —Å—Ç—Ä–∏–º –∑–∞–ø—É—â–µ–Ω (PID: {self.ffmpeg_pid})")
            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ FFmpeg: {e}", exc_info=True)
            return False

    def _monitor_ffmpeg(self):
        """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –ø—Ä–æ—Ü–µ—Å—Å–∞ FFmpeg"""
        try:
            stream_connected = False

            for line in iter(self.stream_process.stderr.readline, b''):
                line = line.decode('utf-8', errors='ignore').strip()

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
                if 'rtmp://' in line and ('connected' in line.lower() or 'connected to' in line.lower()):
                    if not stream_connected:
                        stream_connected = True
                        logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ YouTube RTMP —Å–µ—Ä–≤–µ—Ä—É")
                        socketio.emit('stream_connected', {'status': 'connected'})

                # –õ–æ–≥–∏—Ä—É–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
                if 'frame=' in line and 'fps=' in line:
                    logger.debug(f"FFmpeg: {line}")
                elif 'error' in line.lower() or 'failed' in line.lower():
                    logger.error(f"FFmpeg error: {line}")
                    socketio.emit('stream_error', {'message': line})

            # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞
            self.stream_process.wait()

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ FFmpeg: {e}")
        finally:
            self.is_streaming = False
            if self.ffmpeg_stdin:
                try:
                    self.ffmpeg_stdin.close()
                except:
                    pass

    def _audio_processor(self):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞—É–¥–∏–æ –æ—á–µ—Ä–µ–¥–∏"""
        import numpy as np

        while self.is_streaming:
            try:
                if self.audio_queue:
                    audio_file = self.audio_queue.pop(0)
                    self.is_playing_audio = True
                    self.stream_audio_realtime(audio_file)
                    self.is_playing_audio = False
                else:
                    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–∏—à–∏–Ω—É
                    silence_duration = 0.1  # 100 –º—Å
                    samples = int(self.audio_sample_rate * silence_duration)
                    silence = np.zeros(samples * self.audio_channels, dtype=np.int16).tobytes()

                    if self.ffmpeg_stdin:
                        try:
                            self.ffmpeg_stdin.write(silence)
                            self.ffmpeg_stdin.flush()
                        except:
                            break

                    time.sleep(silence_duration)
            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∞—É–¥–∏–æ: {e}")
                time.sleep(0.1)

    def add_audio_to_queue(self, audio_file: str):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞ –≤ –æ—á–µ—Ä–µ–¥—å –Ω–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ"""
        if not os.path.exists(audio_file):
            logger.error(f"‚ùå –ê—É–¥–∏–æ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {audio_file}")
            return False

        self.audio_queue.append(audio_file)
        logger.info(f"üéµ –ê—É–¥–∏–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å: {os.path.basename(audio_file)}")
        logger.info(f"üìä –û—á–µ—Ä–µ–¥—å –∞—É–¥–∏–æ: {len(self.audio_queue)} —Ñ–∞–π–ª–æ–≤")
        return True

    def send_audio_to_stream(self, audio_data: bytes):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã—Ö –≤ —Å—Ç—Ä–∏–º"""
        if not self.is_streaming or not self.ffmpeg_stdin:
            logger.warning("‚ö†Ô∏è –ù–µ –º–æ–≥—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –∞—É–¥–∏–æ: —Å—Ç—Ä–∏–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω")
            return False

        try:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞—É–¥–∏–æ –≤ FFmpeg
            self.ffmpeg_stdin.write(audio_data)
            self.ffmpeg_stdin.flush()
            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞—É–¥–∏–æ: {e}")
            return False

    def play_audio_file(self, audio_file: str):
        """–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞ (MP3) –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Å—Ç—Ä–∏–º"""
        if not os.path.exists(audio_file):
            logger.error(f"‚ùå –ê—É–¥–∏–æ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω: {audio_file}")
            return False

        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º ffmpeg –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ MP3 –≤ —Å—ã—Ä–æ–µ –∞—É–¥–∏–æ
            ffmpeg_cmd = [
                'ffmpeg',
                '-i', audio_file,  # –í—Ö–æ–¥–Ω–æ–π MP3 —Ñ–∞–π–ª
                '-f', 's16le',  # –§–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–∞: 16-bit PCM
                '-ar', '44100',  # –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
                '-ac', '2',  # –°—Ç–µ—Ä–µ–æ
                '-acodec', 'pcm_s16le',  # –ö–æ–¥–µ–∫ –¥–ª—è –≤—ã—Ö–æ–¥–∞
                '-'  # –í—ã–≤–æ–¥ –≤ stdout
            ]

            logger.debug(f"–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∞—É–¥–∏–æ: {os.path.basename(audio_file)}")

            # –ó–∞–ø—É—Å–∫–∞–µ–º ffmpeg –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
            process = subprocess.Popen(
                ffmpeg_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                bufsize=10 ** 8  # –ë–æ–ª—å—à–æ–π –±—É—Ñ–µ—Ä –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
            )

            # –ß–∏—Ç–∞–µ–º –≤—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Å—Ç—Ä–∏–º
            while True:
                audio_data = process.stdout.read(4096)  # –ß–∏—Ç–∞–µ–º –ø–æ—Ä—Ü–∏—è–º–∏
                if not audio_data:
                    break

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ FFmpeg stdin
                if self.ffmpeg_stdin:
                    try:
                        self.ffmpeg_stdin.write(audio_data)
                        self.ffmpeg_stdin.flush()
                    except BrokenPipeError:
                        logger.error("‚ùå FFmpeg stdin –∑–∞–∫—Ä—ã—Ç")
                        break

            # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
            process.wait()

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ –æ—à–∏–±–∫–∏
            if process.returncode != 0:
                error_output = process.stderr.read().decode('utf-8', errors='ignore')
                logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∞—É–¥–∏–æ: {error_output}")
                return False

            logger.info(f"‚úÖ –ê—É–¥–∏–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —Å—Ç—Ä–∏–º: {os.path.basename(audio_file)}")
            return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞: {e}")
            return False

    def stream_audio_realtime(self, audio_file: str):
        """–°—Ç—Ä–∏–º–∏–Ω–≥ –∞—É–¥–∏–æ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏ —Å —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–µ–π"""
        if not self.is_streaming:
            logger.warning("–°—Ç—Ä–∏–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω")
            return False

        try:
            # –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞—É–¥–∏–æ
            duration = self._get_audio_duration(audio_file)

            # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞—É–¥–∏–æ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏
            ffmpeg_cmd = [
                'ffmpeg',
                '-re',  # –†–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è (–≤–∞–∂–Ω–æ –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏!)
                '-i', audio_file,  # –í—Ö–æ–¥–Ω–æ–π —Ñ–∞–π–ª
                '-f', 's16le',  # –§–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–∞
                '-ar', '44100',  # –ß–∞—Å—Ç–æ—Ç–∞ –¥–∏—Å–∫—Ä–µ—Ç–∏–∑–∞—Ü–∏–∏
                '-ac', '2',  # –°—Ç–µ—Ä–µ–æ
                '-c:a', 'pcm_s16le',  # –ö–æ–¥–µ–∫ –∞—É–¥–∏–æ
                '-'  # –í—ã–≤–æ–¥ –≤ stdout
            ]

            logger.info(f"üéµ –°—Ç—Ä–∏–º–∏–Ω–≥ –∞—É–¥–∏–æ: {os.path.basename(audio_file)} ({duration:.1f} —Å–µ–∫)")

            process = subprocess.Popen(
                ffmpeg_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                bufsize=0
            )

            # –°—Ç—Ä–∏–º–∏–º –∞—É–¥–∏–æ –ø–æ—Ä—Ü–∏—è–º–∏
            chunk_size = 88200  # 0.5 —Å–µ–∫—É–Ω–¥—ã –∞—É–¥–∏–æ (44100 –ì—Ü * 2 –∫–∞–Ω–∞–ª–∞ * 2 –±–∞–π—Ç–∞)

            while True:
                audio_data = process.stdout.read(chunk_size)
                if not audio_data:
                    break

                if self.ffmpeg_stdin:
                    try:
                        self.ffmpeg_stdin.write(audio_data)
                        self.ffmpeg_stdin.flush()
                    except BrokenPipeError:
                        logger.error("FFmpeg –ø–µ—Ä–µ—Å—Ç–∞–ª –ø—Ä–∏–Ω–∏–º–∞—Ç—å –∞—É–¥–∏–æ")
                        break

            process.wait()
            logger.info(f"‚úÖ –ê—É–¥–∏–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ: {os.path.basename(audio_file)}")
            return True

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞ –∞—É–¥–∏–æ: {e}")
            return False

    def _get_audio_duration(self, audio_file: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞ —á–µ—Ä–µ–∑ ffprobe"""
        try:
            cmd = [
                'ffprobe',
                '-v', 'error',
                '-show_entries', 'format=duration',
                '-of', 'csv=p=0',
                audio_file
            ]

            result = subprocess.run(cmd, capture_output=True, text=True)
            if result.returncode == 0:
                return float(result.stdout.strip())
        except:
            pass

        # –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å, –æ—Ü–µ–Ω–∏–≤–∞–µ–º –ø—Ä–∏–º–µ—Ä–Ω–æ
        try:
            # –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞: 0.1 —Å–µ–∫—É–Ω–¥—ã –Ω–∞ —Å–ª–æ–≤–æ
            import re
            with open(audio_file, 'rb') as f:
                # –ß–∏—Ç–∞–µ–º ID3 —Ç–µ–≥ –¥–ª—è MP3
                f.seek(-128, 2)
                tag = f.read(3)
                if tag == b'TAG':
                    # MP3 —Å —Ç–µ–≥–æ–º
                    return 5.0
        except:
            pass

        return 5.0  # –ó–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

    def stream_audio_sync(self, audio_file: str, wait_for_completion: bool = True):
        """–°–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞"""
        if not self.is_streaming:
            logger.warning("–°—Ç—Ä–∏–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω")
            return False

        try:
            # –°–æ–∑–¥–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∏ –∞—É–¥–∏–æ
            ffmpeg_cmd = [
                'ffmpeg',
                '-i', audio_file,
                '-f', 's16le',
                '-ar', '44100',
                '-ac', '2',
                '-'
            ]

            process = subprocess.Popen(
                ffmpeg_cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.DEVNULL,
                bufsize=0
            )

            # –°–æ–∑–¥–∞–µ–º pipe –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö
            def send_audio():
                while True:
                    data = process.stdout.read(4096)
                    if not data:
                        break

                    if self.ffmpeg_stdin:
                        try:
                            self.ffmpeg_stdin.write(data)
                            self.ffmpeg_stdin.flush()
                        except:
                            break

            # –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            audio_thread = threading.Thread(target=send_audio, daemon=True)
            audio_thread.start()

            if wait_for_completion:
                audio_thread.join(timeout=30)  # –ú–∞–∫—Å–∏–º—É–º 30 —Å–µ–∫—É–Ω–¥

            process.wait(timeout=5)
            return True

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ: {e}")
            return False

    def play_audio_simple(self, audio_file: str):
        """–ü—Ä–æ—Å—Ç–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞ (—Å–∞–º—ã–π –Ω–∞–¥–µ–∂–Ω—ã–π –º–µ—Ç–æ–¥)"""
        if not self.is_streaming or not self.ffmpeg_stdin:
            logger.warning("–°—Ç—Ä–∏–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω –∏–ª–∏ stdin –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")
            return False

        try:
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º ffmpeg –¥–ª—è –ø—Ä—è–º–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ rtmp
            ffmpeg_audio_cmd = [
                'ffmpeg',
                '-re',  # –†–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è
                '-i', audio_file,
                '-c:a', 'aac',
                '-b:a', '128k',
                '-ar', '44100',
                '-ac', '2',
                '-f', 'flv',
                self.rtmp_url
            ]

            logger.info(f"‚ñ∂Ô∏è –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ: {os.path.basename(audio_file)}")

            # –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Ç–¥–µ–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –¥–ª—è –∞—É–¥–∏–æ
            process = subprocess.Popen(
                ffmpeg_audio_cmd,
                stdout=subprocess.DEVNULL,
                stderr=subprocess.PIPE
            )

            # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
            process.wait()

            if process.returncode == 0:
                logger.info(f"‚úÖ –ê—É–¥–∏–æ —É—Å–ø–µ—à–Ω–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–æ")
                return True
            else:
                error = process.stderr.read().decode('utf-8', errors='ignore')
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ: {error}")
                return False

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ—Å—Ç–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∞—É–¥–∏–æ: {e}")
            return False

    def stop_stream(self):
        """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç—Ä–∏–º–∞"""
        if self.stream_process:
            logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ FFmpeg —Å—Ç—Ä–∏–º–∞...")
            self.is_streaming = False

            try:
                # –û—á–∏—â–∞–µ–º –æ—á–µ—Ä–µ–¥—å –∞—É–¥–∏–æ
                self.audio_queue.clear()

                # –ó–∞–∫—Ä—ã–≤–∞–µ–º stdin
                if self.ffmpeg_stdin:
                    self.ffmpeg_stdin.close()

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º SIGTERM
                self.stream_process.terminate()

                # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
                for _ in range(20):
                    if self.stream_process.poll() is not None:
                        break
                    time.sleep(0.5)

                # –ï—Å–ª–∏ –≤—Å–µ –µ—â–µ –∂–∏–≤ - SIGKILL
                if self.stream_process.poll() is None:
                    self.stream_process.kill()
                    self.stream_process.wait()

                logger.info("‚úÖ FFmpeg —Å—Ç—Ä–∏–º –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                return True

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ FFmpeg: {e}")
                return False

        return True

    def get_status(self):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞"""
        return {
            'is_streaming': self.is_streaming,
            'stream_key': self.stream_key[:10] + '...' if self.stream_key else None,
            'rtmp_url': self.rtmp_url,
            'pid': self.ffmpeg_pid,
            'video_source': self.video_source,
            'use_pyaudio': self.use_pyaudio,
            'audio_queue_size': len(self.audio_queue),
            'is_playing_audio': self.is_playing_audio
        }

    def get_stream_health(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å—Ç—Ä–∏–º–∞"""
        status = self.get_status()

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∂–∏–≤ –ª–∏ –ø—Ä–æ—Ü–µ—Å—Å
        if self.stream_process:
            status['process_alive'] = (self.stream_process.poll() is None)
            if not status['process_alive']:
                status['exit_code'] = self.stream_process.poll()
        else:
            status['process_alive'] = False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã
        if self.start_time:
            status['uptime'] = time.time() - self.start_time

        return status

    def check_stream_connection(self):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ YouTube (–ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø)"""
        if not self.rtmp_url:
            return {'connected': False, 'error': 'No RTMP URL'}

        try:
            # –ö–æ–º–∞–Ω–¥–∞ –¥–ª—è –ü–†–û–í–ï–†–ö–ò –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è (–Ω–µ —Å—Ç—Ä–∏–º–∏–Ω–≥–∞!)
            # ffprobe —á–∏—Ç–∞–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ, –∞ –Ω–µ —Å—Ç—Ä–∏–º–∏—Ç
            cmd = [
                'ffprobe',
                '-v', 'error',
                '-rw_timeout', '5000000',  # 5 —Å–µ–∫—É–Ω–¥ —Ç–∞–π–º–∞—É—Ç –Ω–∞ —á—Ç–µ–Ω–∏–µ
                '-timeout', '5000000',  # 5 —Å–µ–∫—É–Ω–¥ –æ–±—â–∏–π —Ç–∞–π–º–∞—É—Ç
                '-analyzeduration', '10000000',
                '-probesize', '10000000',
                '-show_entries', 'stream=codec_name',  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
                self.rtmp_url
            ]

            logger.debug(f"–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {' '.join(cmd)}")

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=10
            )

            logger.debug(f"FFprobe —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {result.returncode}")
            logger.debug(f"FFprobe stdout: {result.stdout[:200]}")
            logger.debug(f"FFprobe stderr: {result.stderr[:200]}")

            # YouTube –æ–±—ã—á–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç 1 –¥–∞–∂–µ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–µ
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–æ–∫ –≤ stderr
            if "Connection refused" in result.stderr or "Cannot open" in result.stderr:
                return {'connected': False, 'error': result.stderr[:200]}

            # –ï—Å–ª–∏ –Ω–µ—Ç –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –æ—à–∏–±–æ–∫, —Å—á–∏—Ç–∞–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –≤–æ–∑–º–æ–∂–Ω—ã–º
            return {
                'connected': True if result.returncode == 0 else 'maybe',
                'output': result.stderr[:500]
            }

        except subprocess.TimeoutExpired:
            return {'connected': False, 'error': 'Connection timeout'}
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
            return {'connected': False, 'error': str(e)}

    def create_test_audio(self, text: str = "–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ", voice: str = "male_ru"):
        """–°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞"""
        try:
            import tempfile
            import asyncio
            import edge_tts

            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
            with tempfile.NamedTemporaryFile(suffix='.mp3', delete=False) as tmp:
                temp_path = tmp.name

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—É–¥–∏–æ
            async def generate():
                tts = edge_tts.Communicate(
                    text=text,
                    voice='ru-RU-DmitryNeural' if voice == 'male_ru' else 'ru-RU-SvetlanaNeural'
                )
                await tts.save(temp_path)

            asyncio.run(generate())

            logger.info(f"‚úÖ –¢–µ—Å—Ç–æ–≤–æ–µ –∞—É–¥–∏–æ —Å–æ–∑–¥–∞–Ω–æ: {temp_path}")
            return temp_path

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∞—É–¥–∏–æ: {e}")
            return None


# ========== EDGE TTS MANAGER ==========

class EdgeTTSManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä TTS –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—É–¥–∏–æ –∏ –ø–µ—Ä–µ–¥–∞—á–∏ –≤ —Å—Ç—Ä–∏–º"""

    def __init__(self, ffmpeg_manager: FFmpegStreamManager = None):
        self.cache_dir = 'audio_cache'
        os.makedirs(self.cache_dir, exist_ok=True)
        self.ffmpeg_manager = ffmpeg_manager
        self.voice_map = {
            'male_ru': 'ru-RU-DmitryNeural',
            'male_ru_deep': 'ru-RU-DmitryNeural',
            'female_ru': 'ru-RU-SvetlanaNeural',
            'female_ru_soft': 'ru-RU-DariyaNeural'
        }

        try:
            pygame.mixer.init(frequency=44100, size=-16, channels=2, buffer=2048)
            self.pygame_available = True
        except:
            self.pygame_available = False
            logger.warning("‚ö†Ô∏è Pygame –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è")

        logger.info("Edge TTS Manager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

    async def text_to_speech_and_stream(self, text: str, voice_id: str = 'male_ru', agent_name: str = "") -> Optional[
        str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Å—Ç—Ä–∏–º"""
        try:
            if voice_id not in self.voice_map:
                voice_id = 'male_ru'

            voice_name = self.voice_map[voice_id]

            # –•—ç—à –¥–ª—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
            text_hash = hashlib.md5(f"{text}_{voice_id}".encode()).hexdigest()
            cache_file = os.path.join(self.cache_dir, f"{agent_name}_{text_hash}.mp3")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
            if os.path.exists(cache_file):
                logger.debug(f"‚ôªÔ∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∞—É–¥–∏–æ: {os.path.basename(cache_file)}")
                await self._play_and_stream(cache_file)
                return cache_file

            # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥–æ–ª–æ—Å–∞
            rate = '+0%'
            pitch = '+0Hz'

            if voice_id == 'male_ru_deep':
                rate = '-10%'
                pitch = '-20Hz'
            elif voice_id == 'female_ru_soft':
                rate = '-5%'
                pitch = '+10Hz'

            # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ
            logger.info(f"üîä –ì–µ–Ω–µ—Ä–∞—Ü–∏—è TTS: {agent_name} ({voice_name})")

            communicate = edge_tts.Communicate(
                text=text,
                voice=voice_name,
                rate=rate,
                pitch=pitch
            )

            await communicate.save(cache_file)
            logger.info(f"üíæ –ê—É–¥–∏–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ: {os.path.basename(cache_file)}")

            # –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤ —Å—Ç—Ä–∏–º
            await self._play_and_stream(cache_file)

            return cache_file

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ Edge TTS: {e}", exc_info=True)
            return None

    async def _play_and_stream(self, audio_file: str):
        """–í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∞—É–¥–∏–æ –ª–æ–∫–∞–ª—å–Ω–æ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Å—Ç—Ä–∏–º"""
        try:
            # 1. –õ–æ–∫–∞–ª—å–Ω–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
            if self.pygame_available:
                try:
                    pygame.mixer.music.load(audio_file)
                    pygame.mixer.music.play()
                    logger.debug(f"üîä –õ–æ–∫–∞–ª—å–Ω–æ–µ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ: {os.path.basename(audio_file)}")
                except Exception as e:
                    logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –ª–æ–∫–∞–ª—å–Ω–æ: {e}")

            # 2. –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ YouTube —Å—Ç—Ä–∏–º
            if self.ffmpeg_manager and self.ffmpeg_manager.is_streaming:
                # –ò—Å–ø–æ–ª—å–∑—É–µ–º ThreadPoolExecutor –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(
                    None,
                    self.ffmpeg_manager.play_audio_file,
                    audio_file
                )
                logger.info(f"üì§ –ê—É–¥–∏–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —Å—Ç—Ä–∏–º: {os.path.basename(audio_file)}")

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è: {e}")

    async def speak_direct(self, text: str, voice_id: str = 'male_ru') -> bool:
        """–ü—Ä—è–º–æ–µ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Å—Ç—Ä–∏–º"""
        try:
            logger.info(f"üé§ –û–∑–≤—É—á–∏–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é: {text[:50]}...")

            audio_file = await self.text_to_speech_and_stream(text, voice_id)

            if audio_file:
                # –ñ–¥–µ–º –æ–∫–æ–Ω—á–∞–Ω–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
                duration = self._get_audio_duration(audio_file)
                await asyncio.sleep(duration + 0.5)
                return True
            return False

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä—è–º–æ–≥–æ –æ–∑–≤—É—á–∏–≤–∞–Ω–∏—è: {e}")
            return False

    def _get_audio_duration(self, audio_file: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞"""
        try:
            result = subprocess.run([
                'ffprobe',
                '-v', 'error',
                '-show_entries', 'format=duration',
                '-of', 'default=noprint_wrappers=1:nokey=1',
                audio_file
            ], capture_output=True, text=True)

            duration = float(result.stdout.strip())
            return duration

        except:
            # –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –æ—Ü–µ–Ω–∫–∞: 10 —Å–ª–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
            with open(audio_file, 'rb') as f:
                size = len(f.read())
            return size / (44100 * 2 * 2)


# ========== AI AGENT ==========

class AIAgent:
    """AI –∞–≥–µ–Ω—Ç"""

    def __init__(self, config: Dict[str, Any]):
        self.id = config["id"]
        self.name = config["name"]
        self.expertise = config["expertise"]
        self.personality = config["personality"]
        self.avatar = config["avatar"]
        self.color = config["color"]
        self.voice = config["voice"]
        self.message_history = []

    async def generate_response(self, topic: str, conversation_history: List[str] = None) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ OpenAI"""
        if not openai_client:
            # –î–µ–º–æ-—Ä–µ–∂–∏–º
            demo_responses = [
                f"–ö–∞–∫ —ç–∫—Å–ø–µ—Ä—Ç –≤ {self.expertise.lower()}, —è —Å—á–∏—Ç–∞—é, —á—Ç–æ {topic.lower()} - –≤–∞–∂–Ω–∞—è —Ç–µ–º–∞.",
                f"–° —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è {self.expertise.lower()}, –º–æ–∂–Ω–æ –≤—ã–¥–µ–ª–∏—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–ª—é—á–µ–≤—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤.",
                f"–ú–æ–∏ –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏—è –≤ {self.expertise.lower()} –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç –∏–Ω—Ç–µ—Ä–µ—Å–Ω—ã–µ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã.",
            ]
            return random.choice(demo_responses)

        try:
            system_prompt = f"""–¢—ã {self.name}, —ç–∫—Å–ø–µ—Ä—Ç –≤ –æ–±–ª–∞—Å—Ç–∏ {self.expertise}.
–¢–≤–æ—è –ª–∏—á–Ω–æ—Å—Ç—å: {self.personality}

–¢—ã —É—á–∞—Å—Ç–≤—É–µ—à—å –≤ –Ω–∞—É—á–Ω–æ–π –¥–∏—Å–∫—É—Å—Å–∏–∏ –Ω–∞ YouTube —Å—Ç—Ä–∏–º–µ. –ë—É–¥—å:
- –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–º –∏ —É–≤–∞–∂–∏—Ç–µ–ª—å–Ω—ã–º
- –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω—ã–º
- –ï—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–º –≤ –æ–±—â–µ–Ω–∏–∏
- –ò—Å–ø–æ–ª—å–∑—É–π –ø—Ä–∏–º–µ—Ä—ã –∏–∑ —Å–≤–æ–µ–π –æ–±–ª–∞—Å—Ç–∏

–û—Ç–≤–µ—á–∞–π 2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è–º–∏."""

            user_prompt = f"–¢–µ–º–∞ –¥–∏—Å–∫—É—Å—Å–∏–∏: {topic}\n\n"

            if conversation_history:
                user_prompt += "–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ä–µ–ø–ª–∏–∫–∏:\n"
                for msg in conversation_history[-3:]:
                    user_prompt += f"- {msg}\n"
                user_prompt += "\n"

            user_prompt += f"{self.name}, —á—Ç–æ —Ç—ã –¥—É–º–∞–µ—à—å –ø–æ —ç—Ç–æ–π —Ç–µ–º–µ? (–∫—Ä–∞—Ç–∫–æ, 2-3 –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è)"

            # –í—ã–∑–æ–≤ OpenAI API
            response = await asyncio.to_thread(
                openai_client.chat.completions.create,
                model=Config.OPENAI_MODEL,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.8,
                max_tokens=250
            )

            message = response.choices[0].message.content.strip()

            # –û—á–∏—â–∞–µ–º –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã
            if message.startswith(f"{self.name}:"):
                message = message[len(f"{self.name}:"):].strip()
            if message.startswith('"') and message.endswith('"'):
                message = message[1:-1]

            self.message_history.append(message[:100] + "...")

            return message

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ—Ç–≤–µ—Ç–∞ –¥–ª—è {self.name}: {e}")
            return f"–ö–∞–∫ —ç–∫—Å–ø–µ—Ä—Ç –≤ {self.expertise.lower()}, —è —Å—á–∏—Ç–∞—é, —á—Ç–æ {topic.lower()} —Ç—Ä–µ–±—É–µ—Ç –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∏–∑—É—á–µ–Ω–∏—è."


# ========== AI STREAM MANAGER ==========

class AIStreamManager:
    """–ú–µ–Ω–µ–¥–∂–µ—Ä —Å—Ç—Ä–∏–º–∞"""

    def __init__(self, ffmpeg_manager: FFmpegStreamManager = None):
        self.agents: List[AIAgent] = []
        self.tts_manager = EdgeTTSManager(ffmpeg_manager)
        self.ffmpeg_manager = ffmpeg_manager
        self.current_topic = ""
        self.is_discussion_active = False
        self.message_count = 0
        self.discussion_round = 0
        self.active_agent = None
        self.conversation_history = []

        self._init_agents()
        logger.info(f"AI Stream Manager –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω —Å {len(self.agents)} –∞–≥–µ–Ω—Ç–∞–º–∏")

    def _init_agents(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–≥–µ–Ω—Ç–æ–≤"""
        for agent_config in Config.AGENTS:
            agent = AIAgent(agent_config)
            self.agents.append(agent)

    def select_topic(self) -> str:
        """–í—ã–±–æ—Ä —Ç–µ–º—ã"""
        self.current_topic = random.choice(Config.TOPICS)
        logger.info(f"üìù –í—ã–±—Ä–∞–Ω–∞ —Ç–µ–º–∞: {self.current_topic}")
        socketio.emit('topic_update', {'topic': self.current_topic})
        return self.current_topic

    async def run_discussion_round(self):
        """–ó–∞–ø—É—Å–∫ —Ä–∞—É–Ω–¥–∞ –¥–∏—Å–∫—É—Å—Å–∏–∏ —Å –æ—Ç–ø—Ä–∞–≤–∫–æ–π –∑–≤—É–∫–∞ –≤ —Å—Ç—Ä–∏–º"""
        if self.is_discussion_active:
            return

        self.is_discussion_active = True
        self.discussion_round += 1

        try:
            if not self.current_topic:
                self.select_topic()

            logger.info(f"üöÄ –ù–∞—á–∞–ª–æ —Ä–∞—É–Ω–¥–∞ #{self.discussion_round}")

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –≤—ã—Å—Ç—É–ø–ª–µ–Ω–∏–π
            speaking_order = random.sample(self.agents, len(self.agents))

            for agent in speaking_order:
                if not self.is_discussion_active:
                    break

                # –ê–≥–µ–Ω—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç –≥–æ–≤–æ—Ä–∏—Ç—å
                self.active_agent = agent.id
                socketio.emit('agent_start_speaking', {
                    'agent_id': agent.id,
                    'agent_name': agent.name,
                    'expertise': agent.expertise
                })

                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ—Ç–≤–µ—Ç–∞ —á–µ—Ä–µ–∑ OpenAI
                logger.info(f"ü§ñ {agent.name} –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç...")
                message = await agent.generate_response(
                    self.current_topic,
                    self.conversation_history
                )

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∏—Å—Ç–æ—Ä–∏—é
                self.conversation_history.append(f"{agent.name}: {message}")
                self.message_count += 1

                # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ WebSocket
                socketio.emit('new_message', {
                    'agent_id': agent.id,
                    'agent_name': agent.name,
                    'message': message,
                    'expertise': agent.expertise,
                    'avatar': agent.avatar,
                    'color': agent.color,
                    'timestamp': datetime.now().isoformat()
                })

                logger.info(f"üí¨ {agent.name}: {message[:80]}...")

                # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—É–¥–∏–æ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤ —Å—Ç—Ä–∏–º
                logger.info(f"üîä –ì–µ–Ω–µ—Ä–∞—Ü–∏—è TTS –¥–ª—è {agent.name}...")

                audio_task = asyncio.create_task(
                    self.tts_manager.text_to_speech_and_stream(
                        text=message,
                        voice_id=agent.voice,
                        agent_name=agent.name
                    )
                )

                # –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∞—É–¥–∏–æ
                audio_file = await audio_task

                if audio_file:
                    logger.info(f"‚úÖ –ê—É–¥–∏–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {os.path.basename(audio_file)}")

                    # –ü–æ–ª—É—á–∞–µ–º –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞—É–¥–∏–æ
                    try:
                        audio_duration = self._get_audio_duration(audio_file)
                    except:
                        # –ü—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
                        word_count = len(message.split())
                        audio_duration = max(3, min(word_count * 0.4, 15))

                    logger.info(f"‚è±Ô∏è  –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞—É–¥–∏–æ: {audio_duration:.1f} —Å–µ–∫")

                    # –ñ–¥–µ–º –ø–æ–∫–∞ –∞—É–¥–∏–æ –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ—Ç—Å—è
                    await asyncio.sleep(audio_duration)
                else:
                    # –ï—Å–ª–∏ –∞—É–¥–∏–æ –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–ª–æ—Å—å
                    word_count = len(message.split())
                    pause_duration = max(3, min(word_count * 0.3, 10))
                    logger.warning(f"‚ö†Ô∏è –ê—É–¥–∏–æ –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ, –∂–¥–µ–º {pause_duration} —Å–µ–∫")
                    await asyncio.sleep(pause_duration)

                # –ê–≥–µ–Ω—Ç –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç –≥–æ–≤–æ—Ä–∏—Ç—å
                socketio.emit('agent_stop_speaking', {'agent_id': agent.id})
                self.active_agent = None

                # –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏
                if agent != speaking_order[-1]:
                    pause = random.uniform(1.5, 3.0)
                    logger.debug(f"‚è∏Ô∏è  –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∞–≥–µ–Ω—Ç–∞–º–∏: {pause:.1f} —Å–µ–∫")
                    await asyncio.sleep(pause)

            logger.info(f"‚úÖ –†–∞—É–Ω–¥ #{self.discussion_round} –∑–∞–≤–µ—Ä—à–µ–Ω")

            socketio.emit('round_complete', {
                'round': self.discussion_round,
                'total_messages': self.message_count,
                'next_round_in': Config.DISCUSSION_INTERVAL
            })

            # –ü–∞—É–∑–∞ –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–∏–º —Ä–∞—É–Ω–¥–æ–º
            await asyncio.sleep(Config.DISCUSSION_INTERVAL)

            # –°–ª—É—á–∞–π–Ω–∞—è —Å–º–µ–Ω–∞ —Ç–µ–º—ã
            if random.random() > 0.7:
                self.select_topic()

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ä–∞—É–Ω–¥–µ –¥–∏—Å–∫—É—Å—Å–∏–∏: {e}", exc_info=True)

            socketio.emit('error', {
                'message': f'–û—à–∏–±–∫–∞ –≤ –¥–∏—Å–∫—É—Å—Å–∏–∏: {str(e)}',
                'round': self.discussion_round
            })

        finally:
            self.is_discussion_active = False
            self.active_agent = None

    def _get_audio_duration(self, audio_file: str) -> float:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∞—É–¥–∏–æ —Ñ–∞–π–ª–∞"""
        try:
            result = subprocess.run([
                'ffprobe',
                '-v', 'error',
                '-show_entries', 'format=duration',
                '-of', 'default=noprint_wrappers=1:nokey=1',
                audio_file
            ], capture_output=True, text=True)

            duration = float(result.stdout.strip())
            return duration

        except Exception as e:
            logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∞—É–¥–∏–æ: {e}")
            return 5.0

    def get_agents_state(self) -> List[Dict[str, Any]]:
        """–°–æ—Å—Ç–æ—è–Ω–∏–µ –∞–≥–µ–Ω—Ç–æ–≤"""
        return [
            {
                'id': agent.id,
                'name': agent.name,
                'expertise': agent.expertise,
                'avatar': agent.avatar,
                'color': agent.color,
                'is_speaking': agent.id == self.active_agent,
                'message_count': len(agent.message_history)
            }
            for agent in self.agents
        ]

    def get_stats(self) -> Dict[str, Any]:
        """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"""
        return {
            'message_count': self.message_count,
            'discussion_round': self.discussion_round,
            'current_topic': self.current_topic,
            'is_active': self.is_discussion_active,
            'active_agent': self.active_agent,
            'agents_count': len(self.agents),
            'conversation_history': len(self.conversation_history),
            'ffmpeg_streaming': self.ffmpeg_manager.is_streaming if self.ffmpeg_manager else False
        }


# ========== –ì–õ–û–ë–ê–õ–¨–ù–´–ï –û–ë–™–ï–ö–¢–´ ==========

ffmpeg_manager = FFmpegStreamManager()
stream_manager = AIStreamManager(ffmpeg_manager)


# ========== –ê–°–ò–ù–•–†–û–ù–ù–´–ô –¶–ò–ö–õ ==========

async def discussion_loop():
    """–û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –¥–∏—Å–∫—É—Å—Å–∏–∏"""
    await asyncio.sleep(2)
    logger.info("üîÑ –ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –¥–∏—Å–∫—É—Å—Å–∏–∏")
    stream_manager.select_topic()

    while True:
        try:
            if not stream_manager.is_discussion_active:
                await stream_manager.run_discussion_round()
            await asyncio.sleep(0.5)
        except asyncio.CancelledError:
            break
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º —Ü–∏–∫–ª–µ: {e}", exc_info=True)
            await asyncio.sleep(5)


def start_discussion_loop():
    """–ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(discussion_loop())


# ========== FLASK –†–û–£–¢–´ ==========

@app.route('/')
def index():
    """–ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞"""
    return render_template('index.html',
                           agents=stream_manager.get_agents_state(),
                           topic=stream_manager.current_topic or "–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–µ–º—ã...",
                           stats=stream_manager.get_stats(),
                           youtube_api_available=YOUTUBE_API_AVAILABLE)


@app.route('/health')
def health():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è"""
    return jsonify({
        'status': 'ok',
        'time': datetime.now().isoformat(),
        'agents': len(stream_manager.agents),
        'streaming': ffmpeg_manager.is_streaming,
        'discussion_active': stream_manager.is_discussion_active,
        'youtube_api_available': YOUTUBE_API_AVAILABLE
    })


@app.route('/api/start_stream', methods=['POST'])
def start_stream():
    """–ó–∞–ø—É—Å–∫ FFmpeg —Å—Ç—Ä–∏–º–∞ (–ø—Ä–∏–Ω–∏–º–∞–µ—Ç —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã)"""
    try:
        # –ü—Ä–∏–Ω–∏–º–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        if request.is_json:
            data = request.get_json()
        else:
            try:
                data = json.loads(request.data.decode('utf-8'))
            except:
                return jsonify({
                    'status': 'error',
                    'message': 'Content-Type –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å application/json'
                }), 415

        stream_key = data.get('stream_key', '')
        if not stream_key:
            return jsonify({
                'status': 'error',
                'message': 'Stream Key –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω'
            }), 400

        logger.info(f"üì® –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —Å—Ç—Ä–∏–º–∞")

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∫–ª—é—á
        ffmpeg_manager.set_stream_key(stream_key)

        # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤–∏–¥–µ–æ –∏—Å—Ç–æ—á–Ω–∏–∫
        video_source = data.get('video_source', 'black')
        ffmpeg_manager.set_video_source(video_source)

        # –ó–∞–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–∏–º
        use_audio = data.get('use_audio', True)
        if ffmpeg_manager.start_stream(use_audio=use_audio):
            return jsonify({
                'status': 'started',
                'rtmp_url': ffmpeg_manager.rtmp_url,
                'pid': ffmpeg_manager.ffmpeg_pid,
                'video_source': ffmpeg_manager.video_source,
                'message': 'YouTube —Å—Ç—Ä–∏–º —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω'
            })
        else:
            return jsonify({
                'status': 'error',
                'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å FFmpeg –ø—Ä–æ—Ü–µ—Å—Å'
            }), 500

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å—Ç—Ä–∏–º–∞: {e}", exc_info=True)
        return jsonify({
            'status': 'error',
            'message': f'–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'
        }), 500


@app.route('/api/start_youtube_stream', methods=['POST'])
def start_youtube_stream():
    """–ó–∞–ø—É—Å–∫ —Å—Ç—Ä–∏–º–∞ —á–µ—Ä–µ–∑ YouTube API (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ–∑–¥–∞–Ω–∏–µ)"""
    try:
        if not YOUTUBE_API_AVAILABLE or not youtube_api_manager:
            return jsonify({
                'status': 'error',
                'message': 'YouTube API –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏ client_secrets.json'
            }), 501

        # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
        if request.is_json:
            data = request.get_json()
        else:
            data = request.form

        title = data.get('title', "ü§ñ AI Agents Live: –ù–∞—É—á–Ω—ã–µ –¥–µ–±–∞—Ç—ã –ò–ò")
        description = data.get('description', Config.STREAM_DESCRIPTION)

        logger.info(f"üé¨ –ó–∞–ø—É—Å–∫ YouTube —Å—Ç—Ä–∏–º–∞ —á–µ—Ä–µ–∑ API: {title}")

        # –ó–∞–ø—É—Å–∫–∞–µ–º —Å—Ç—Ä–∏–º —á–µ—Ä–µ–∑ YouTube API
        try:
            success = youtube_api_manager.start_stream(title, description)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ YouTube API: {e}")
            return jsonify({
                'status': 'error',
                'message': f'–û—à–∏–±–∫–∞ YouTube API: {str(e)}'
            }), 500

        if not success:
            return jsonify({
                'status': 'error',
                'message': '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é'
            }), 500

        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç—Ä–∏–º–µ
        try:
            stream_info = youtube_api_manager.get_stream_info()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è stream_info: {e}")
            return jsonify({
                'status': 'error',
                'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ç—Ä–∏–º–µ'
            }), 500

        if not stream_info or 'stream_key' not in stream_info:
            return jsonify({
                'status': 'error',
                'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Stream Key –æ—Ç YouTube API'
            }), 500

        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º stream key –≤ FFmpeg manager
        ffmpeg_manager.set_stream_key(stream_info['stream_key'])

        # –ó–∞–ø—É—Å–∫–∞–µ–º FFmpeg —Å—Ç—Ä–∏–º
        if ffmpeg_manager.start_stream():
            return jsonify({
                'status': 'started',
                'broadcast_id': youtube_api_manager.broadcast_id,
                'stream_id': youtube_api_manager.stream_id,
                'watch_url': f"https://youtube.com/watch?v={youtube_api_manager.broadcast_id}",
                'stream_key': stream_info['stream_key'],
                'rtmp_url': stream_info['rtmp_url'],
                'pid': ffmpeg_manager.ffmpeg_pid,
                'message': 'YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ –∏ —Å—Ç—Ä–∏–º –∑–∞–ø—É—â–µ–Ω'
            })
        else:
            # –ï—Å–ª–∏ FFmpeg –Ω–µ –∑–∞–ø—É—Å—Ç–∏–ª—Å—è, –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é
            try:
                youtube_api_manager.end_stream()
            except:
                pass
            return jsonify({
                'status': 'error',
                'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å FFmpeg —Å—Ç—Ä–∏–º'
            }), 500

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ YouTube —Å—Ç—Ä–∏–º–∞: {e}", exc_info=True)
        return jsonify({
            'status': 'error',
            'message': f'–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {str(e)}'
        }), 500


@app.route('/api/youtube_control', methods=['POST'])
def youtube_control():
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–µ–π"""
    try:
        if not YOUTUBE_API_AVAILABLE or not youtube_api_manager:
            return jsonify({
                'status': 'error',
                'message': 'YouTube API –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω'
            }), 501

        if request.is_json:
            data = request.get_json()
        else:
            data = request.form

        action = data.get('action', '')

        if action == 'get_info':
            try:
                info = youtube_api_manager.get_stream_info()
                return jsonify({
                    'status': 'success',
                    'broadcast_id': youtube_api_manager.broadcast_id,
                    'stream_id': youtube_api_manager.stream_id,
                    'is_live': youtube_api_manager.is_live,
                    'stream_info': info
                })
            except Exception as e:
                return jsonify({
                    'status': 'error',
                    'message': f'–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏: {str(e)}'
                })

        elif action == 'update_info':
            try:
                title = data.get('title')
                description = data.get('description')
                result = youtube_api_manager.update_broadcast_info(title, description)
                if result:
                    return jsonify({'status': 'updated'})
                return jsonify({'status': 'error', 'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})

        elif action == 'end_stream':
            try:
                # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º FFmpeg
                ffmpeg_manager.stop_stream()
                # –ó–∞–≤–µ—Ä—à–∞–µ–º YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é
                result = youtube_api_manager.end_stream()
                if result:
                    return jsonify({'status': 'ended'})
                return jsonify({'status': 'error', 'message': '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≤–µ—Ä—à–∏—Ç—å'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})

        elif action == 'get_chat_id':
            try:
                chat_id = youtube_api_manager.get_chat_id()
                if chat_id:
                    return jsonify({'status': 'success', 'chat_id': chat_id})
                return jsonify({'status': 'error', 'message': '–ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})

        elif action == 'create_test_stream':
            try:
                title = data.get('title', '–¢–µ—Å—Ç–æ–≤–∞—è —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è')
                description = data.get('description', '–¢–µ—Å—Ç–æ–≤–∞—è —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞ —á–µ—Ä–µ–∑ API')

                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é
                broadcast = youtube_api_manager.create_live_broadcast(title, description)
                stream = youtube_api_manager.create_stream()

                if broadcast and stream:
                    youtube_api_manager.bind_broadcast_to_stream()
                    return jsonify({
                        'status': 'created',
                        'broadcast_id': youtube_api_manager.broadcast_id,
                        'stream_id': youtube_api_manager.stream_id
                    })
                return jsonify({'status': 'error', 'message': '–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å'})
            except Exception as e:
                return jsonify({'status': 'error', 'message': str(e)})

        else:
            return jsonify({
                'status': 'error',
                'message': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ',
                'available_actions': ['get_info', 'update_info', 'end_stream', 'get_chat_id', 'create_test_stream']
            })

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è YouTube: {e}")
        return jsonify({'status': 'error', 'message': str(e)})


@app.route('/api/youtube_status')
def youtube_status():
    """–°—Ç–∞—Ç—É—Å YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏"""
    try:
        if not YOUTUBE_API_AVAILABLE or not youtube_api_manager:
            return jsonify({
                'available': False,
                'message': 'YouTube API –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω'
            })

        return jsonify({
            'available': True,
            'has_broadcast': youtube_api_manager.broadcast_id is not None,
            'has_stream': youtube_api_manager.stream_id is not None,
            'is_live': youtube_api_manager.is_live,
            'broadcast_id': youtube_api_manager.broadcast_id,
            'stream_id': youtube_api_manager.stream_id
        })
    except Exception as e:
        return jsonify({
            'available': False,
            'error': str(e)
        })


@app.route('/api/stop_stream', methods=['POST'])
def stop_stream():
    """–û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å—Ç—Ä–∏–º–∞"""
    try:
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–∞
        if YOUTUBE_API_AVAILABLE and youtube_api_manager and youtube_api_manager.is_live:
            try:
                youtube_api_manager.end_stream()
            except Exception as e:
                logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é: {e}")

        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º FFmpeg
        if ffmpeg_manager.stop_stream():
            return jsonify({'status': 'stopped', 'message': '–°—Ç—Ä–∏–º –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'})
        return jsonify({'status': 'error', 'message': '–°—Ç—Ä–∏–º –Ω–µ –±—ã–ª –∑–∞–ø—É—â–µ–Ω'})
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å—Ç—Ä–∏–º–∞: {e}")
        return jsonify({'status': 'error', 'message': str(e)})


@app.route('/api/stream_status')
def stream_status():
    """–°—Ç–∞—Ç—É—Å —Å—Ç—Ä–∏–º–∞"""
    status = ffmpeg_manager.get_status()

    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ YouTube API
    if YOUTUBE_API_AVAILABLE and youtube_api_manager:
        status['youtube'] = {
            'available': True,
            'has_broadcast': youtube_api_manager.broadcast_id is not None,
            'is_live': youtube_api_manager.is_live,
            'broadcast_id': youtube_api_manager.broadcast_id
        }
    else:
        status['youtube'] = {'available': False}

    return jsonify(status)


@app.route('/api/stream_stats')
def stream_stats():
    """–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å—Ç—Ä–∏–º–∞"""
    stats = stream_manager.get_stats()
    stats.update(ffmpeg_manager.get_status())

    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ YouTube
    if YOUTUBE_API_AVAILABLE and youtube_api_manager:
        stats['youtube'] = {
            'broadcast_id': youtube_api_manager.broadcast_id,
            'is_live': youtube_api_manager.is_live,
            'stream_id': youtube_api_manager.stream_id
        }

    return jsonify(stats)


@app.route('/api/control', methods=['POST'])
def control():
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∏—Å–∫—É—Å—Å–∏–µ–π"""
    try:
        data = request.get_json()
        action = data.get('action', '')

        if action == 'start_discussion':
            stream_manager.is_discussion_active = True
            return jsonify({'status': 'started'})

        elif action == 'stop_discussion':
            stream_manager.is_discussion_active = False
            return jsonify({'status': 'stopped'})

        elif action == 'change_topic':
            topic = stream_manager.select_topic()
            return jsonify({'status': 'changed', 'topic': topic})

        elif action == 'get_topic':
            return jsonify({'topic': stream_manager.current_topic})

        else:
            return jsonify({'status': 'error', 'message': '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ'})

    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)})


@app.route('/api/test_audio', methods=['POST'])
def test_audio():
    """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–≤—É–∫–∞ –≤ —Å—Ç—Ä–∏–º–µ"""
    try:
        if not ffmpeg_manager.is_streaming:
            return jsonify({
                'status': 'error',
                'message': '–°—Ç—Ä–∏–º –Ω–µ –∑–∞–ø—É—â–µ–Ω. –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å—Ç—Ä–∏–º —Å–Ω–∞—á–∞–ª–∞.'
            }), 400

        data = request.get_json()
        text = data.get('text', '–¢–µ—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–≤—É–∫–∞ –Ω–∞ —Å—Ç—Ä–∏–º–µ.')
        voice = data.get('voice', 'male_ru')

        # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        def run_test():
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(
                stream_manager.tts_manager.speak_direct(text, voice)
            )

        threading.Thread(target=run_test, daemon=True).start()

        return jsonify({
            'status': 'success',
            'message': f'–¢–µ—Å—Ç–æ–≤–æ–µ –∞—É–¥–∏–æ –∑–∞–ø—É—â–µ–Ω–æ: "{text[:50]}..."',
            'voice': voice
        })

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∞—É–¥–∏–æ: {e}")
        return jsonify({'status': 'error', 'message': str(e)})


@app.route('/api/test_youtube_connection')
def test_youtube_connection():
    """–¢–µ—Å—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ YouTube"""
    try:
        if not ffmpeg_manager.stream_key:
            return jsonify({
                'status': 'error',
                'message': 'Stream Key –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω'
            })

        result = ffmpeg_manager.check_stream_connection()
        return jsonify(result)
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)})


@app.route('/youtube-control')
def youtube_control_page():
    """–°—Ç—Ä–∞–Ω–∏—Ü–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è YouTube API"""
    return render_template('youtube_control.html',
                           youtube_api_available=YOUTUBE_API_AVAILABLE)


# ========== WEBSOCKET HANDLERS ==========

@socketio.on('connect')
def handle_connect():
    """–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞"""
    client_id = request.sid
    logger.info(f"üì± –ö–ª–∏–µ–Ω—Ç –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è: {client_id}")

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    socketio.emit('connected', {
        'status': 'connected',
        'client_id': client_id,
        'agents': stream_manager.get_agents_state(),
        'topic': stream_manager.current_topic or stream_manager.select_topic(),
        'stats': stream_manager.get_stats(),
        'stream_status': ffmpeg_manager.get_status(),
        'server_time': datetime.now().isoformat(),
        'youtube_api_available': YOUTUBE_API_AVAILABLE,
        'youtube_broadcast_id': youtube_api_manager.broadcast_id if youtube_api_manager else None,
        'youtube_is_live': youtube_api_manager.is_live if youtube_api_manager else False
    })


@socketio.on('disconnect')
def handle_disconnect():
    """–û—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–ª–∏–µ–Ω—Ç–∞"""
    logger.info(f"üì± –ö–ª–∏–µ–Ω—Ç –æ—Ç–∫–ª—é—á–∏–ª—Å—è: {request.sid}")


@socketio.on('request_update')
def handle_update_request():
    """–ó–∞–ø—Ä–æ—Å –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è"""
    socketio.emit('update', {
        'agents': stream_manager.get_agents_state(),
        'topic': stream_manager.current_topic,
        'stats': stream_manager.get_stats(),
        'stream_status': ffmpeg_manager.get_status(),
        'youtube_broadcast_id': youtube_api_manager.broadcast_id if youtube_api_manager else None,
        'youtube_is_live': youtube_api_manager.is_live if youtube_api_manager else False
    })


# ========== –ó–ê–ü–£–°–ö –°–ï–†–í–ï–†–ê ==========

def signal_handler(signum, frame):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–æ–≤"""
    print(f"\nüõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª {signum}. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ...")

    # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç—Ä–∏–º
    if ffmpeg_manager.is_streaming:
        ffmpeg_manager.stop_stream()

    # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–∞
    if YOUTUBE_API_AVAILABLE and youtube_api_manager and youtube_api_manager.is_live:
        try:
            youtube_api_manager.end_stream()
        except:
            pass

    sys.exit(0)


if __name__ == '__main__':
    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    print("=" * 70)
    print("ü§ñ AI AGENTS STREAM WITH FFMPEG")
    print("=" * 70)

    # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç—è—Ö
    print(f"üì¶ –í–µ—Ä—Å–∏–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:")
    print(f"   Flask: 2.3.0")
    print(f"   Flask-SocketIO: 5.3.0")
    print(f"   OpenAI: >=1.3.0")
    print(f"   Edge TTS: >=6.1.9")
    print(f"   FFmpeg: —Å–∏—Å—Ç–µ–º–Ω—ã–π")

    if YOUTUBE_API_AVAILABLE:
        print(f"   YouTube API: –î–æ—Å—Ç—É–ø–µ–Ω ‚úÖ")
    else:
        print(f"   YouTube API: –ù–µ –¥–æ—Å—Ç—É–ø–µ–Ω (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä—É—á–Ω–æ–π Stream Key)")

    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    os.makedirs("stream_ui", exist_ok=True)
    os.makedirs("audio_cache", exist_ok=True)

    # –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∞—É–¥–∏–æ —Ñ–∞–π–ª—ã
    if os.path.exists('audio_cache'):
        try:
            for filename in os.listdir('audio_cache'):
                file_path = os.path.join('audio_cache', filename)
                try:
                    if os.path.isfile(file_path) or os.path.islink(file_path):
                        os.unlink(file_path)
                    elif os.path.isdir(file_path):
                        shutil.rmtree(file_path)
                except Exception as e:
                    logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å {file_path}: {e}")
            print("‚úÖ –û—á–∏—â–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è audio_cache")
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ audio_cache: {e}")
    else:
        os.makedirs('audio_cache', exist_ok=True)

    # –°–æ–∑–¥–∞–µ–º UI –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
    ui_dir = "stream_ui"
    if not os.path.exists(ui_dir):
        os.makedirs(ui_dir, exist_ok=True)

    # –°–æ–∑–¥–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π index.html
    index_path = os.path.join(ui_dir, "index.html")
    if not os.path.exists(index_path):
        print("üìÅ –°–æ–∑–¥–∞—é –æ—Å–Ω–æ–≤–Ω–æ–π UI...")
        with open(index_path, 'w', encoding='utf-8') as f:
            f.write('''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>AI Stream Control</title>
    <style>
        body { font-family: Arial; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .panel { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .online { background: #d4edda; }
        .offline { background: #f8d7da; }
        .info { background: #d1ecf1; }
        button { margin: 5px; padding: 10px 20px; border: none; cursor: pointer; border-radius: 5px; }
        .btn-primary { background: #007bff; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn-danger { background: #dc3545; color: white; }
        .agent-card { display: inline-block; padding: 15px; margin: 10px; border-radius: 8px; }
        .speaking { border: 3px solid #28a745; }
        .message { background: white; padding: 10px; margin: 5px 0; border-radius: 5px; border-left: 4px solid #007bff; }
    </style>
</head>
<body>
    <h1>ü§ñ AI Stream Control Panel</h1>

    <div class="panel">
        <h2>üìä –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã</h2>
        <div id="system-status" class="status offline">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
        <div id="agents-container"></div>
    </div>

    <div class="panel">
        <h2>üé¨ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–∏–º–æ–º</h2>
        <div>
            <button class="btn-primary" onclick="manualStream()">üîë –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —Å—Ç—Ä–∏–º–∞</button>
            <button class="btn-success" onclick="youtubeApiStream()">üöÄ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π YouTube —Å—Ç—Ä–∏–º</button>
            <button class="btn-danger" onclick="stopStream()">üõë –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∏–º</button>
            <a href="/youtube-control" target="_blank">
                <button class="btn-primary">‚öôÔ∏è YouTube API Control</button>
            </a>
        </div>
    </div>

    <div class="panel">
        <h2>üí¨ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∏—Å–∫—É—Å—Å–∏–µ–π</h2>
        <div id="topic-display">–¢–µ–º–∞: <span id="current-topic">–ó–∞–≥—Ä—É–∑–∫–∞...</span></div>
        <button class="btn-primary" onclick="startDiscussion()">‚ñ∂Ô∏è –ù–∞—á–∞—Ç—å –¥–∏—Å–∫—É—Å—Å–∏—é</button>
        <button class="btn-danger" onclick="stopDiscussion()">‚è∏Ô∏è –û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–∏—Å–∫—É—Å—Å–∏—é</button>
        <button class="btn-primary" onclick="changeTopic()">üîÑ –°–º–µ–Ω–∏—Ç—å —Ç–µ–º—É</button>
        <button class="btn-primary" onclick="testAudio()">üîä –¢–µ—Å—Ç –∑–≤—É–∫–∞</button>
    </div>

    <div class="panel">
        <h2>üì® –°–æ–æ–±—â–µ–Ω–∏—è</h2>
        <div id="messages-container"></div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        const socket = io();

        socket.on('connected', function(data) {
            updateSystemStatus(data);
            updateAgents(data.agents);
            document.getElementById('current-topic').textContent = data.topic;
        });

        socket.on('update', function(data) {
            updateSystemStatus(data);
            updateAgents(data.agents);
            document.getElementById('current-topic').textContent = data.topic;
        });

        socket.on('stream_connected', function(data) {
            alert('‚úÖ –°—Ç—Ä–∏–º —É—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ YouTube!');
            document.getElementById('system-status').className = 'status online';
            document.getElementById('system-status').innerHTML = '–°—Ç—Ä–∏–º –∞–∫—Ç–∏–≤–µ–Ω –∏ –ø–æ–¥–∫–ª—é—á–µ–Ω –∫ YouTube';
        });

        socket.on('new_message', function(data) {
            addMessage(data);
        });

        socket.on('agent_start_speaking', function(data) {
            highlightAgent(data.agent_id, true);
        });

        socket.on('agent_stop_speaking', function(data) {
            highlightAgent(data.agent_id, false);
        });

        function updateSystemStatus(data) {
            const statusDiv = document.getElementById('system-status');
            let html = `<strong>–°—Ç–∞—Ç—É—Å:</strong> `;

            if(data.stream_status.is_streaming) {
                statusDiv.className = 'status online';
                html += `–°—Ç—Ä–∏–º –∞–∫—Ç–∏–≤–µ–Ω (PID: ${data.stream_status.pid})<br>`;
                html += `<strong>RTMP URL:</strong> ${data.stream_status.rtmp_url || '–ù–µ —É–∫–∞–∑–∞–Ω'}<br>`;
            } else {
                statusDiv.className = 'status offline';
                html += `–°—Ç—Ä–∏–º –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω<br>`;
            }

            html += `<strong>–ê–≥–µ–Ω—Ç–æ–≤:</strong> ${data.agents.length}<br>`;
            html += `<strong>–°–æ–æ–±—â–µ–Ω–∏–π:</strong> ${data.stats.message_count}<br>`;
            html += `<strong>–†–∞—É–Ω–¥:</strong> ${data.stats.discussion_round}`;

            statusDiv.innerHTML = html;
        }

        function updateAgents(agents) {
            const container = document.getElementById('agents-container');
            let html = '';

            agents.forEach(agent => {
                html += `<div class="agent-card ${agent.is_speaking ? 'speaking' : ''}" 
                         style="background: ${agent.color}; color: white; min-width: 200px;">
                    <strong>${agent.name}</strong><br>
                    <small>${agent.expertise}</small><br>
                    <span>–°–æ–æ–±—â–µ–Ω–∏–π: ${agent.message_count}</span>
                    ${agent.is_speaking ? '<br><span>üé§ –ì–æ–≤–æ—Ä–∏—Ç</span>' : ''}
                </div>`;
            });

            container.innerHTML = html;
        }

        function addMessage(data) {
            const container = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.innerHTML = `
                <strong>${data.agent_name}</strong> (${data.expertise})<br>
                ${data.message}<br>
                <small>${new Date(data.timestamp).toLocaleTimeString()}</small>
            `;
            container.insertBefore(messageDiv, container.firstChild);
        }

        function highlightAgent(agentId, isSpeaking) {
            const agents = document.querySelectorAll('.agent-card');
            agents.forEach(card => {
                if(card.textContent.includes(agentId)) {
                    if(isSpeaking) {
                        card.classList.add('speaking');
                    } else {
                        card.classList.remove('speaking');
                    }
                }
            });
        }

        function manualStream() {
            const key = prompt('–í–≤–µ–¥–∏—Ç–µ YouTube Stream Key:');
            if(key) {
                fetch('/api/start_stream', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({stream_key: key})
                })
                .then(res => res.json())
                .then(data => {
                    if(data.status === 'started') {
                        alert('‚úÖ –°—Ç—Ä–∏–º –∑–∞–ø—É—â–µ–Ω!');
                    } else {
                        alert('‚ùå –û—à–∏–±–∫–∞: ' + data.message);
                    }
                });
            }
        }

        function youtubeApiStream() {
            if(!confirm('–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π YouTube —Å—Ç—Ä–∏–º —á–µ—Ä–µ–∑ API?\n(–¢—Ä–µ–±—É–µ—Ç—Å—è client_secrets.json)')) {
                return;
            }

            const title = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏:', 'ü§ñ AI Agents Live: –ù–∞—É—á–Ω—ã–µ –¥–µ–±–∞—Ç—ã –ò–ò');
            if(title) {
                fetch('/api/start_youtube_stream', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({title: title})
                })
                .then(res => res.json())
                .then(data => {
                    if(data.status === 'started') {
                        alert(`‚úÖ YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞!\n–°–º–æ—Ç—Ä–µ—Ç—å: ${data.watch_url}`);
                    } else {
                        alert('‚ùå –û—à–∏–±–∫–∞: ' + data.message);
                    }
                });
            }
        }

        function stopStream() {
            if(confirm('–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∏–º?')) {
                fetch('/api/stop_stream', {
                    method: 'POST'
                })
                .then(res => res.json())
                .then(data => {
                    if(data.status === 'stopped') {
                        alert('‚úÖ –°—Ç—Ä–∏–º –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
                    } else {
                        alert('‚ùå –û—à–∏–±–∫–∞: ' + data.message);
                    }
                });
            }
        }

        function startDiscussion() {
            fetch('/api/control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action: 'start_discussion'})
            })
            .then(res => res.json())
            .then(data => {
                if(data.status === 'started') {
                    alert('‚úÖ –î–∏—Å–∫—É—Å—Å–∏—è –Ω–∞—á–∞—Ç–∞');
                }
            });
        }

        function stopDiscussion() {
            fetch('/api/control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action: 'stop_discussion'})
            })
            .then(res => res.json())
            .then(data => {
                if(data.status === 'stopped') {
                    alert('‚úÖ –î–∏—Å–∫—É—Å—Å–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞');
                }
            });
        }

        function changeTopic() {
            fetch('/api/control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action: 'change_topic'})
            })
            .then(res => res.json())
            .then(data => {
                if(data.status === 'changed') {
                    alert('‚úÖ –¢–µ–º–∞ –∏–∑–º–µ–Ω–µ–Ω–∞: ' + data.topic);
                }
            });
        }

        function testAudio() {
            const text = prompt('–¢–µ–∫—Å—Ç –¥–ª—è —Ç–µ—Å—Ç–∞ –∑–≤—É–∫–∞:', '–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ —Ç–µ—Å—Ç –∑–≤—É–∫–∞ –Ω–∞ YouTube —Å—Ç—Ä–∏–º–µ.');
            if(text) {
                fetch('/api/test_audio', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({text: text, voice: 'male_ru'})
                })
                .then(res => res.json())
                .then(data => {
                    alert(data.message);
                });
            }
        }

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞
        setInterval(() => {
            fetch('/api/stream_status')
            .then(res => res.json())
            .then(data => {
                socket.emit('request_update');
            });
        }, 5000);
    </script>
</body>
</html>''')

    # –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è YouTube API
    youtube_control_path = os.path.join(ui_dir, "youtube_control.html")
    if not os.path.exists(youtube_control_path):
        print("üìÅ –°–æ–∑–¥–∞—é YouTube API UI...")
        with open(youtube_control_path, 'w', encoding='utf-8') as f:
            f.write('''<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>YouTube API Control</title>
    <style>
        body { font-family: Arial; padding: 20px; max-width: 800px; margin: 0 auto; }
        .panel { background: #f5f5f5; padding: 20px; border-radius: 10px; margin: 20px 0; }
        .btn { background: #4285f4; color: white; border: none; padding: 10px 20px; margin: 5px; cursor: pointer; border-radius: 5px; }
        .btn:hover { background: #3367d6; }
        .btn-danger { background: #ea4335; }
        .btn-success { background: #34a853; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .online { background: #d4edda; }
        .offline { background: #f8d7da; }
        .info { background: #d1ecf1; }
        input, textarea { width: 100%; padding: 8px; margin: 5px 0; }
    </style>
</head>
<body>
    <h1>üé¨ YouTube API Control Panel</h1>

    <div id="youtube-status" class="status offline">
        YouTube API: –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏...
    </div>

    <div class="panel">
        <h3>–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏</h3>
        <div>
            <label>–ù–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏:</label><br>
            <input type="text" id="stream-title" value="ü§ñ AI Agents Live: –ù–∞—É—á–Ω—ã–µ –¥–µ–±–∞—Ç—ã –ò–ò">
        </div>
        <div>
            <label>–û–ø–∏—Å–∞–Ω–∏–µ:</label><br>
            <textarea id="stream-description" rows="8"></textarea>
        </div>
        <button class="btn btn-success" onclick="startYoutubeStream()">üé¨ –°–æ–∑–¥–∞—Ç—å YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é</button>
        <button class="btn" onclick="checkYouTubeStatus()">üîÑ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å</button>
    </div>

    <div class="panel" id="stream-controls" style="display: none;">
        <h3>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–µ–π</h3>
        <div id="stream-info" class="status info">–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞</div>
        <button class="btn" onclick="updateStreamInfo()">‚úèÔ∏è –û–±–Ω–æ–≤–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é</button>
        <button class="btn" onclick="getChatId()">üí¨ –ü–æ–ª—É—á–∏—Ç—å ID —á–∞—Ç–∞</button>
        <button class="btn btn-danger" onclick="endYoutubeStream()">üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é</button>
    </div>

    <div class="panel">
        <h3>–°—Ç–∞—Ç—É—Å FFmpeg</h3>
        <div id="ffmpeg-status" class="status">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
        <button class="btn" onclick="checkFFmpegStatus()">üîÑ –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å FFmpeg</button>
    </div>

    <script>
        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–ø–æ–ª–Ω—è–µ–º –æ–ø–∏—Å–∞–Ω–∏–µ
        document.getElementById('stream-description').value = `–ê–≤—Ç–æ–Ω–æ–º–Ω—ã–µ –ò–ò-–∞–≥–µ–Ω—Ç—ã –æ–±—Å—É–∂–¥–∞—é—Ç –Ω–∞—É–∫—É –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏.

–£—á–∞—Å—Ç–Ω–∏–∫–∏:
‚Ä¢ –î–æ–∫—Ç–æ—Ä –ê–ª–µ–∫—Å–µ–π –í–æ–ª–∫–æ–≤ - –ö–≤–∞–Ω—Ç–æ–≤–∞—è —Ñ–∏–∑–∏–∫–∞
‚Ä¢ –ü—Ä–æ—Ñ–µ—Å—Å–æ—Ä –ú–∞—Ä–∏—è –°–æ–∫–æ–ª–æ–≤–∞ - –ù–µ–π—Ä–æ–±–∏–æ–ª–æ–≥–∏—è
‚Ä¢ –î–æ–∫—Ç–æ—Ä –ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤ - –ö–ª–∏–º–∞—Ç–æ–ª–æ–≥–∏—è
‚Ä¢ –ò—Å—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å –°–æ—Ñ–∏—è –ö–æ–≤–∞–ª–µ–≤–∞ - –ò–ò –∏ —Ä–æ–±–æ—Ç–æ—Ç–µ—Ö–Ω–∏–∫–∞

–¢–µ–º—ã: –ò—Å–∫—É—Å—Å—Ç–≤–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç, –∫–≤–∞–Ω—Ç–æ–≤—ã–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è, –∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–ª–∏–º–∞—Ç–∞, –Ω–µ–π—Ä–æ–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã.

–°—Ç—Ä–∏–º —Å–æ–∑–¥–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å –ø–æ–º–æ—â—å—é Python –∏ OpenAI GPT-4.`;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å YouTube API –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        window.addEventListener('load', function() {
            checkYouTubeStatus();
            checkFFmpegStatus();
        });

        function checkYouTubeStatus() {
            fetch('/api/youtube_control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action: 'get_info'})
            })
            .then(res => res.json())
            .then(data => {
                const statusDiv = document.getElementById('youtube-status');
                if(data.status === 'success') {
                    statusDiv.className = 'status online';
                    statusDiv.innerHTML = 'YouTube API: –î–æ—Å—Ç—É–ø–µ–Ω';
                    document.getElementById('stream-controls').style.display = 'block';
                    updateStreamInfoDisplay(data);
                } else {
                    statusDiv.className = 'status offline';
                    statusDiv.innerHTML = 'YouTube API: –ù–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ client_secrets.json';
                }
            })
            .catch(err => {
                document.getElementById('youtube-status').className = 'status offline';
                document.getElementById('youtube-status').innerHTML = 'YouTube API: –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è';
            });
        }

        function startYoutubeStream() {
            const title = document.getElementById('stream-title').value;
            const description = document.getElementById('stream-description').value;

            if(!title.trim()) {
                alert('–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏');
                return;
            }

            fetch('/api/start_youtube_stream', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({title, description})
            })
            .then(res => res.json())
            .then(data => {
                if(data.status === 'started') {
                    alert('‚úÖ YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∞!\\n–°—Å—ã–ª–∫–∞: ' + data.watch_url);
                    document.getElementById('stream-controls').style.display = 'block';
                    updateStreamInfoDisplay({
                        status: 'success',
                        broadcast_id: data.broadcast_id,
                        stream_id: data.stream_id,
                        is_live: true,
                        stream_info: {
                            stream_key: data.stream_key,
                            rtmp_url: data.rtmp_url
                        }
                    });
                } else {
                    alert('‚ùå –û—à–∏–±–∫–∞: ' + data.message);
                }
            })
            .catch(err => {
                alert('‚ùå –û—à–∏–±–∫–∞ —Å–µ—Ç–∏: ' + err);
            });
        }

        function updateStreamInfo() {
            const title = document.getElementById('stream-title').value;
            const description = document.getElementById('stream-description').value;

            fetch('/api/youtube_control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    action: 'update_info',
                    title: title,
                    description: description
                })
            })
            .then(res => res.json())
            .then(data => {
                if(data.status === 'updated') {
                    alert('‚úÖ –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∞');
                } else {
                    alert('‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è');
                }
            });
        }

        function getChatId() {
            fetch('/api/youtube_control', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({action: 'get_chat_id'})
            })
            .then(res => res.json())
            .then(data => {
                if(data.chat_id) {
                    alert('üí¨ ID —á–∞—Ç–∞: ' + data.chat_id);
                } else {
                    alert('‚ùå –ß–∞—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω');
                }
            });
        }

        function endYoutubeStream() {
            if(confirm('–ó–∞–≤–µ—Ä—à–∏—Ç—å YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—é?')) {
                fetch('/api/youtube_control', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({action: 'end_stream'})
                })
                .then(res => res.json())
                .then(data => {
                    if(data.status === 'ended') {
                        alert('‚úÖ –¢—Ä–∞–Ω—Å–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
                        document.getElementById('stream-controls').style.display = 'none';
                        document.getElementById('stream-info').innerHTML = '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞';
                    } else {
                        alert('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è');
                    }
                });
            }
        }

        function updateStreamInfoDisplay(data) {
            const infoDiv = document.getElementById('stream-info');
            let html = '';

            if(data.broadcast_id) {
                html += `<strong>ID —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–∏:</strong> ${data.broadcast_id}<br>`;
                html += `<strong>–°—Ç–∞—Ç—É—Å:</strong> ${data.is_live ? '–í —ç—Ñ–∏—Ä–µ üü¢' : '–ù–µ –≤ —ç—Ñ–∏—Ä–µ üî¥'}<br>`;
                html += `<strong>Stream Key:</strong> ${data.stream_info?.stream_key || '–ù–µ —É–∫–∞–∑–∞–Ω'}<br>`;
                html += `<strong>RTMP URL:</strong> ${data.stream_info?.rtmp_url || '–ù–µ —É–∫–∞–∑–∞–Ω'}`;
            }

            infoDiv.innerHTML = html || '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –¥–æ—Å—Ç—É–ø–Ω–∞';
        }

        function checkFFmpegStatus() {
            fetch('/api/stream_status')
            .then(res => res.json())
            .then(data => {
                const statusDiv = document.getElementById('ffmpeg-status');
                if(data.is_streaming) {
                    statusDiv.className = 'status online';
                    statusDiv.innerHTML = `FFmpeg: –†–∞–±–æ—Ç–∞–µ—Ç (PID: ${data.pid})<br>
                                           RTMP: ${data.rtmp_url || '–ù–µ —É–∫–∞–∑–∞–Ω'}`;
                } else {
                    statusDiv.className = 'status offline';
                    statusDiv.innerHTML = 'FFmpeg: –ù–µ –∑–∞–ø—É—â–µ–Ω';
                }
            })
            .catch(err => {
                document.getElementById('ffmpeg-status').innerHTML = 'FFmpeg: –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏';
            });
        }
    </script>
</body>
</html>''')

    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ—Ç–æ–∫ –¥–∏—Å–∫—É—Å—Å–∏–∏
    print("üîÑ –ó–∞–ø—É—Å–∫ —Ü–∏–∫–ª–∞ –¥–∏—Å–∫—É—Å—Å–∏–∏...")
    discussion_thread = threading.Thread(target=start_discussion_loop, daemon=True)
    discussion_thread.start()

    print("üöÄ –ó–∞–ø—É—Å–∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞...")
    print("üåê –û—Å–Ω–æ–≤–Ω–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: http://localhost:5000")
    print("üé¨ YouTube API –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å: http://localhost:5000/youtube-control")
    print("üîß API Endpoints:")
    print("   GET  /health                     - –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è")
    print("   POST /api/start_stream           - –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ —Å—Ç—Ä–∏–º–∞")
    print("   POST /api/start_youtube_stream   - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ YouTube API")
    print("   POST /api/youtube_control        - –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ YouTube —Ç—Ä–∞–Ω—Å–ª—è—Ü–∏–µ–π")
    print("   GET  /api/stream_status          - –°—Ç–∞—Ç—É—Å —Å—Ç—Ä–∏–º–∞")
    print("   POST /api/test_audio             - –¢–µ—Å—Ç –∑–≤—É–∫–∞")
    print("")
    print("üìù –î–æ—Å—Ç—É–ø–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∑–∞–ø—É—Å–∫–∞ —Å—Ç—Ä–∏–º–∞:")
    print("   1. –†—É—á–Ω–æ–π: –í–≤–µ—Å—Ç–∏ Stream Key –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ")
    print("   2. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å YouTube API (—Ç—Ä–µ–±—É–µ—Ç—Å—è client_secrets.json)")
    print("=" * 70)

    try:
        socketio.run(app,
                     host='0.0.0.0',
                     port=5000,
                     debug=False,
                     use_reloader=False,
                     allow_unsafe_werkzeug=True)
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {e}")
        print(f"\n‚ùå –û—à–∏–±–∫–∞: {e}")